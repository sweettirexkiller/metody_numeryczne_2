a = [5,6,7];
b = [1,2,3,4];
c = [8,9,10];

n = size(b);
n = n(2);

% macierz 4x4
%  1  8  0  0
%  5  2  9  0
%  0  6  3  10
%  0  0  7  4


[p,q,s,Householdery] = RobHouseholderaTrzyDiagonalnie(a,b,c);

sprawdzenie = [p(1) q(1) s(1) 0 ; 0 p(2) q(2) s(2); 0 0 p(3) q(3); 0 0 0 p(4)];
% powinna byc troj diagonalna trojkatna gorna
% sprawdzenie

% Hn-1*...*H1A = R (p,q,s)
%test
% H0*....Hn-1*R = A
%powinno zniknac s a pojawic sie znow a
a_new = zeros(1,n -1);
b_new = zeros(1, n);
c_new = zeros(1, n -1);
s_new = zeros(1, n-2);

%rozpoczynamy moznenie

for i = (n-1: -1:1)
   if(i == n -1)
    H = Householdery(:,:,i);
    R = [p(i),q(i); 0, p(i+1)];
    temp = H3*R1;
    
    a_new(i) = temp(2,1);
    b_new(i) = temp(1,1);
    b_new(i+1) = temp(2,2);
    c_new(i) = temp(1,2);

   else % i == 1

   end
end

%i = n - 1;
Hn_1 = Householdery(:,:,n - 1);
R1 = [p(3),q(3); 0, p(4)];
temp = H3*R1;

a_new(n-1) = temp(2,1);
b_new(n-1) = temp(1,1);
b_new(n) = temp(2,2);
c_new(n-1) = temp(1,2);

% i = n - 2;
Hn_2 = Householdery(:,:, n-2);
R2 = [p(n-2), q(n-2), s(n-2); 0, b_new(n-1), c_new(n-1)];
temp = Hn_2*R2;

a_new(n-2) = temp(2,1);
b_new(n-2) = temp(1,1);
c_new(n-2) = temp(1, 2);
c_new(n-1) = temp(2,3);
s_new(n-2) = temp(1,3);
b_new(n-1) = temp(2,2);

% i = n - 3 == 1 (ostatni householder) 

Hn_3 = Householdery(:,:, n-3);
R3 = [p(n-3), q(n-3), s(n-3); 0, b_new(n-2), c_new(n-2)];
R3

temp = Hn_3*R3


a_new(n-3) = temp(2,1);
b_new(n-3) = temp(1,1);
c_new(n-3) = temp(1, 2);
c_new(n-2) = temp(2,3);
s_new(n-3) = temp(1,3);
b_new(n-2) = temp(2,2);

a_new
b_new
c_new



% Q = H0*H1*....*Hn-1
% Q = H0*H1*....Hn-1*I


% A = Q*R

